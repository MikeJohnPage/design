# Use multiple functions for complex strategies {#sec-strategy-functions}

```{r}
#| include = FALSE
source("common.R")
```

## What's the problem?

You have **complex strategies** when different strategies require different arguments.
In this case, it's a good idea to use a separate function for each strategy, to make it as clear as possible which arguments belong to which strategy.
One sign that you have this pattern that you have a complex dependency between arguments: maybe you can set `a` and `b` and `a` and `c` but not `b` and `c`.
This tends to make the function harder to use because it suggests more viable input combinations than actually exist.

## What are some examples?

This problem is typically discovered in hindsight.

-   `forcats::fct_lump()` chooses between one of three lumping strategies depending on whether you supply just `n`, just `prop`, or neither, while supplying both `n` and `prop` is an error.
    Additionally, the `ties.method` argument only does anything if you supply only `n`.
    `fct_lump()` is hard to document because it's really three smaller functions in trench coat[^strategy-functions-1].

-   `seq_along()` and `seq_len()` implement two common strategies for creating sequences starting at 1: matching the length of existing vector, or given the maximum `n`.

-   `runif()`, `rnorm()` ?

-   `isTRUE`, `isFALSE`?

-   `log10`, `log2`, `log` ?

-   I think `rep()` would be easier to understand if it was two separate functions because it exposes two basic strategies: either repeating each element or the full vector.
    Learn more in @sec-cs-rep.

[^strategy-functions-1]: <https://tvtropes.org/pmwiki/pmwiki.php/Main/TotemPoleTrench>

## How do I remediate past mistakes?

Remediating past mistakes is straightforward: define, document, and export one function for each strategy.
Then rewrite the original function to use those strategies, deprecating that entire function if desired.

```{r}
fct_lump <- function(f,
                     n,
                     prop,
                     w = NULL,
                     other_level = "Other",
                     ties.method = c("min", "average", "first", "last", "random", "max")) {
    if (missing(n) && missing(prop)) {
      fct_lump_lowfreq(f, w = w, other_level = other_level)
    } else if (missing(prop)) {
      fct_lump_n(f, n, w = w, other_level = other_level, ties.method = ties.method)
    } else if (missing(n)) {
      fct_lump_prop(f, prop, w = w, other_level = other_level)
    } else {
      cli::cli_abort("Must supply only one of {.arg n} and {.arg prop}.")
    }
}
```

In forcats we decided to supersede `fct_lump()` rather than deprecating it.
Deprecating it would only require one extra line:

```{r}
fct_lump <- function(...) {
  lifecycle::deprecate_warn("0.5.0", "fct_lump()")
}
```
