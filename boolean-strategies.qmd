# Avoid Boolean strategies {#sec-avoid-boolean-strategies}

```{r}
#| include = FALSE
source("common.R")
```

## What's the pattern?

If your function provides only two strategies it's tempting to use a logical to switch between them.
I recommend against this unless you're REALLY SURE there won't ever be another strategy.
There are two reasons:

-   If you do discover a third strategy, you'll need to carefully remediate your function.
-   In many cases, you can be more express with a enumeration than a Boolean argument.

## What are some examples?

Compare these equivalent calls to `sort()` and `vctrs::vec_sort()`:

```{r}
#| results: false

x <- sample(10)
sort(x, decreasing = TRUE)
vctrs::vec_sort(x, direction = "desc")

sort(x, decreasing = FALSE)
vctrs::vec_sort(x, direction = "asc")
```

It's unlikely that you'll ever need to implement another sorting direction, but I think it's easier to understand `direction = "asc"` than `decreasing = FALSE` at a glance.

Another example where I think an enumeration is easier to understand is the `cols_vary` argument to `pivot_longer()`.
This argument can be either fastest or slowest, and it's hard to imagine how you might encode that into a Boolean flag.

## How do you remediate past mistakes?

### New argument

Remediating this problem will typically require adding a new argument and deprecating the old argument.
For example, imagine we wanted to remediate the `na.last` argument to `sort()`.
It exposes uses a Boolean to expose three strategies for handling missing values:

-   `na.last = TRUE` means put them last.
-   `na.last = FALSE` means put them first.
-   `na.list = NA` means to drop them.

I think we could make this function more clear by adding a new `na` argument that takes one of three values: `last`, `first`, or `drop`.

```{r}
sort <- function(x, na.last = lifecycle::deprecated(), na = c("drop", "first", "last")) {
  
  if (lifecycle::is_present(na.last)) {
    lifecycle::deprecate_warn("1.0.0", "sort(na.last)", "sort(na)")

    if (!is.logical(na.last) || length(na.last) != 1) {
      cli::cli_abort("{.arg na.last} must be a single TRUE, FALSE, or NA.")
    }
    
    if (isTRUE(na.last)) {
      na <- "last"
    } else if (isFALSE(na.last)) {
      na <- "first"
    } else {
      na <- "drop"
    }
  } else {
    na <- arg_match(na)
  }
}
```

Note that because `na` is a prefix of `na.last` and `na.last` comes before `â€¦` (in violation of @sec-dots-after-required), this introduces a very subtle behaviour change: a call like `sort(x, n = TRUE)` would have previously worked and been equivalent to `sort(x, na.last = TRUE)` but will now fail because it matches both `na` and `na.last`.

It would also be nice to make the default value `"last"` since it's very unusual for an R function to silently remove missing values.
However, that is much more likely to be a breaking change, affecting much existing code, so is unlikely to be worthwhile.

### Same name

Sometimes you get lucky and you can use the same argument name for both the boolean and the strategy.
For example, `haven::write_sav()` originally allowed `compress` to be either `TRUE` or `FALSE`.
But then SPSS introduced a new way of compressing, expanding the set of options to three (which we have called byte, none, and zsav).
Since the `compress` argument name is still good we chose to accept either a `TRUE` or `FALSE` or one of the new enumeratiion:

```{r}
write_sav <- function(data, path, compress = c("byte", "none", "zsav"), adjust_tz = TRUE) {
  if (isTRUE(compress)) {
    compress <- "zsav"
  } else if (isFALSE(compress)) {
    compress <- "none"
  } else {
    compress <- arg_match(compress)
  }

  ...
}
```

You could also imagine deprecating the old logical options, but here we chose to the keep them since it's a small amount of extra code, and means that existing users never need to worry about it.
See `?haven::read_sav` for how we communicated the in the docs.
